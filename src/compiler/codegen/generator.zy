module compiler.codegen

import compiler.ast.nodes.{Node, NodeKind}
import core.types.Result
import runtime.vm.{Value, ValueType}

/**
 * CodeGen
 *
 * Manages the code generation process, including instructions, constants, and errors.
 */
type CodeGen {
	instructions: []byte
	constants: []Value
	errors: []string
}

/**
 * new_codegen
 *
 * Initializes a new CodeGen instance.
 *
 * @return CodeGen The initialized CodeGen instance.
 */
fn new_codegen() -> CodeGen {
	CodeGen {
		instructions: [],
		constants: [],
		errors: []
	}
}

/**
 * generate
 *
 * Generates bytecode and constants from the given AST.
 *
 * @param ast The abstract syntax tree to generate bytecode from.
 * @return Result<([]byte, []Value)> The generated bytecode and constants, or an error if generation fails.
 */
fn generate(ast: Node) -> Result<([]byte, []Value)> {
	let gen = new_codegen()
	gen.generate_node(ast)?
	
	if gen.errors.length > 0 {
		return Err(join(gen.errors, "\n"))
	}
	
	Ok((gen.instructions, gen.constants))
}

/**
 * generate_node
 *
 * Generates bytecode for the given AST node.
 *
 * @param self The CodeGen instance.
 * @param node The AST node to generate bytecode for.
 * @return Result<()> An error if generation fails.
 */
fn generate_node(self: &mut CodeGen, node: Node) -> Result<()> {
	match node.kind {
		NodeKind.MODULE => {
			for child in node.children {
				self.generate_node(child)?
			}
		},
		NodeKind.FUNCTION => {
			// For now, we only handle the main function
			if node.value == "main" {
				self.generate_block(node.children[0])?
			}
		},
		NodeKind.BLOCK => {
			for stmt in node.children {
				self.generate_node(stmt)?
			}
		},
		NodeKind.CALL_EXPR => {
			// Push function name
			let const_idx = self.add_constant(Value{
				type: ValueType.STRING,
				string_val: node.value
			})
			self.emit(Opcode.LOAD_CONST, const_idx)

			// Generate code for arguments
			for arg in node.children {
				self.generate_node(arg)?
			}

			self.emit(Opcode.CALL, node.children.length)
		},
		NodeKind.STRING_LITERAL => {
			let const_idx = self.add_constant(Value{
				type: ValueType.STRING,
				string_val: node.value
			})
			self.emit(Opcode.LOAD_CONST, const_idx)
		},
		NodeKind.RETURN_STMT => {
			if node.children.length > 0 {
				self.generate_node(node.children[0])?
			}
			self.emit(Opcode.RETURN, 0)
		},
		_ => self.errors.push(f"Unsupported node type: {node.kind}")
return Err(f"Unsupported node type: {node.kind}")
	}

	Ok(())
}

/**
 * emit
 *
 * Emits an instruction with the given opcode and operand.
 *
 * @param self The CodeGen instance.
 * @param opcode The opcode to emit.
 * @param operand The operand to emit.
 */
fn emit(self: &mut CodeGen, opcode: Opcode, operand: byte) {
	self.instructions.push(opcode)
	self.instructions.push(operand)
}

/**
 * add_constant
 *
 * Adds a constant to the constants table and returns its index.
 *
 * @param self The CodeGen instance.
 * @param value The constant value to add.
 * @return byte The index of the added constant.
 */
fn add_constant(self: &mut CodeGen, value: Value) -> byte {
	self.constants.push(value)
	return (self.constants.length - 1) as byte
}
